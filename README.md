基于Netty的轻量级、高性能RPC分布式框架的开发手册



# 框架说明

框架功能特性：

* 支持服务器集群化部署，并搭配有节点集群的容错机制、节点均衡和出错重试功能。
* 支持注册中心，客户端可以选择使用注册中心进行rpc，也可以手动指定节点群。
* 支持SSL加密，采用服务器单向认证。
* 支持对于SPI扩展点接口进行自定义扩展。目前支持用户自定义的扩展点包括：解压缩算法、序列化算法、节点均衡器、回调线程池、业务线程池、注册中心的注册器、发现器。
  * 目前支持的压缩算法：不使用压缩、Snappy、Gzip。
  * 目前支持的序列化算法：Jdk、Json、Protostuff。
  * 目前支持的均衡器：轮询、随机。
* 同时支持同步和异步的rpc操作。客户端既可以同步等待结果，也可以定义回调任务来异步操作结果。
* 支持自定义TCP连接参数来调节并发量，支持流量整形来保护服务器。
* 对于Linux系统，服务器和客户端支持使用基于Epoll的SocketChannel实现。相较于NIO实现，Epoll的gc更少，效率更高。



# 开发历史

> 2022/2/17：0.1版本。使用Netty框架简单写了一个小demo，基本熟悉了协议设计、编解码器、方法反射执行等rpc基础部分。
>
> 2022/3/8：1.0版本。实现基本的同步的RPC通信。节点管理器、业务处理链、rpc服务扫描器、SPI扫描器、流量整形器等框架核心部分完成；服务器客户端TCP参数确定。支持集群、支持序列化、压缩算法的SPI扩展等功能。可以实现RPC的基本功能的使用。
>
> 2022/3/10：1.1版本。同时同步异步的RPC操作。ResponseFuture、Mapping、回调线程池等部分完成。支持异步RPC操作。
>
> 2022/3/13：1.5版本。支持SSL加密，使用服务器单向认证，为RPC框架的安全性提供了保障。
>
> 2022/3/14：2.0版本。支持注册中心。注册中心的发布器、发现器基于Curator完成，节点集群无需客户端手动指定，客户端只需要提供一个需要调用的RPC方法名即可。





# RPC通信原理

我的RPC框架的架构原理如下图所示。

![image.png](https://pic.rmb.bdstatic.com/bjh/1764381cf8e41ed1e4d0016bd4d71e7d.png)



# 框架详解

## 1.使用的协议

协议头部包含2B魔数（固定为`1998`）、1B的标志位、1B的解码参数、8B的序号、4B的报文长度。

![image.png](https://pic.rmb.bdstatic.com/bjh/57774bf8eef2e2626106af11584b103f.png)



客户端服务器就是按照此规则进行编解码的。想了解这部分具体源码，请点击：

[**基于Netty，自定义网络协议的编解码器的实现和使用**](http://www.conghucai.site/#/article/700766e9a3674705bd1a7274000a3915)



## 2.服务器客户端设计

框架是基于Netty框架的，Netty的Handler规定了一系列对于Channel上的数据的操作逻辑。我们从Handler结构来了解框架的实现。

服务器和客户端使用的Handler结构是相同的，只是在`ConnectManagerHandler`和`ProcessHandler`部分的具体操作有不同。其中，绿色部分的Handler实质上都是`ChannelDuplexHandler`双向处理器，最后的`ProcessHandler`是一个`SimpleChannelInboundHandler`入站处理，专门用于处理经过解密、解码之后的消息对象。

其中许多Handler都使用了SPI扩展点，用户可以根据自己的需求实现接口来进行功能扩展。框架使用了Dubbo的改进版SPI机制，效率更高，想详细了解源码，请点击：

[**精度这篇博文，从源码理解Dubbo是如何实现SPI服务扩展机制的**](http://www.conghucai.site/#/article/ec8881f17c0d42ebbf924d2e69c2b75c)



服务器和客户端实现相同的Handler有：

* `IdleSateHandler`是闲置状态检测，用于检测假死的连接并关闭。
* `Codec`是编解码器。遵循定义好的协议进行编解码。
* `SSLHandler`在服务器和客户端之间进行认真和加解密。
* `TrafficShapingHandler`是进行流量整形的。

![image.png](https://pic.rmb.bdstatic.com/bjh/c600f4ef469e7b7b4149466c443e1b94.png)





## 3.数据交互过程

从客户端到服务器，请求数据到响应数据按照以下顺序进行：



### 3.1 节点管理

*详细了解这一部分源码，请点击：*  [**【轻量级RPC框架开发系列Ⅰ】服务集群部署关键：连接管理器的设计实现**](http://www.conghucai.site/#/article/591b55f9c3614b739294e85b901d6827)

当客户端通过rpc接口调用远程服务时，客户端会使用`ProcessHandler`构建请求包并通过Channel发送出去。

针对用户传入的服务器集群信息，客户端会保持一个Node Manager对客户端指定的服务器集群进行管理，它起到的作用主要包括：

* 连接维持：周期性发送心跳包维持和每个服务节点的TCP连接。
* 过滤器：记录节点的出错次数，用于判断和过滤出错次数过多的节点。
* 连接池：维持和每个服务节点的连接池，池中有若干连接对象，每个连接对象都是一个channel，来增强连接的可靠性、减少重复的连接操作。
* 均衡器：以某种规定的均衡规则（轮询、随机等）来从集群中选择一个节点进行rpc。提高集群的资源利用率。



从**客户端**角度来看，节点管理器对服务节点集群进行管理，其工作流程是这样的：

![image.png](https://pic.rmb.bdstatic.com/bjh/78a29290ba5e4f7754ce15546ce5c7d1.png)



**服务器的节点管理器**就是简单维持和各个客户端的连接池，并将长时间未发生读写时间的连接关闭。





这个节点集群既可以用户手动指定，也可以使用**注册中心**。

使用注册中心时，服务器使用`Publisher`将自己需要暴露的服务注册到注册中心中，框架内部设计的注册路径格式为：

> myrpc.
>
> > serviceName.
> >
> > > 192.168.0.13:10001
> > >
> > > 192.168.0.13:10002
> > >
> > > 192.168.0.13:10003

客户端使用远程方法`serviceName`到注册中心中进行服务发现，就可以得到路径下的服务集群列表。

注册中心的工作流程示意图：

![image.png](https://pic.rmb.bdstatic.com/bjh/283f55479ad45f2694418df0c11a9b7d.png)

### 3.2 业务处理链

*详细了解这一部分源码，请点击：*  [**【轻量级RPC框架开发系列Ⅲ】服务器-客户端通用的业务处理链模块设计**](http://www.conghucai.site/#/article/8bb1f0e0cae54a94b9b29f7621cb2268)

之后消息通过编码、加密，传输到服务器，服务器进行解密、解码，得到一个完整的消息对象。

服务器的`ProcessHandler`内包含一条业务处理链，将按照链中的流程依次对数据进行操作。其设计如下：

![image.png](https://pic.rmb.bdstatic.com/bjh/67212fb2b24d4fb0d6fbe99a527515a6.png)



其中最重要的处理单元就是图中的分发处理单元(`DispatcherUnit`)，其会对消息类型进行一个判断：

* 如果是一个心跳包，返回一个200响应包即可。我这里的响应码是完全参考Http的。
* 如果是一个rpc请求，那么要从其中拿到调用的服务名，通过Java反射机制拿到方法的执行器并执行，将执行结果打包成响应包，发送给客户端。



### 3.3 同步和异步原理

*详细了解这一部分源码，请点击：*   [**【轻量级RPC框架开发系列Ⅱ】RPC框架实现同步/异步的关键组件：ResponseFuture的设计**](http://www.conghucai.site/#/article/bc2a8e833dab40c6bf899a876ca7c81a)

响应包发送后，客户端有两种方式进行接收，即同步和异步两种。

实现同步和异步的关键就在于`ResponseFuture`组件，以及一个future的过期缓存`ResponseMapping`，还有回调任务的封装接口。

当客户端发送数据后，生成一个请求包的序号对应的future对象，并放在缓存中。当收到响应后，根据响应的序号去缓存里寻找对应的future对象：

* 如果没找到则说明响应超时
* 找到了的话，发送数据的主线程和接收数据的io线程就可以操作同一对象了。

**`ResponseFuture`扮演的就是两线程之间的一个对象容器。**

需要实现同步的话，在future里面放一把同步锁就可以。流程如下：

![image.png](https://mapp.alicdn.com/16473117249931oVWOJCIi7CPTrw.png)



需要实现异步的话，在future里面封装好异步操作的代码即可，这段代码将由io线程在收到响应后开启执行。

![image.png](https://mapp.alicdn.com/1647312013852qTSVD5kjsORTciI.png)

客户端就完成了对于远程服务器的一次RPC操作。这就是整个框架的工作原理。



